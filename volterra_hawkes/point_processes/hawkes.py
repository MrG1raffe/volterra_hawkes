import numpy as np
from numpy.typing import NDArray
from numpy import float64
from typing import Callable, Union

from .poisson import inhomogeneous_poisson_field_on_interval_thinning, inhomogeneous_poisson_field_on_interval_inversion
from ..kernel.exponential_kernel import ExponentialKernel
from ..kernel.kernel import Kernel


def simulate_hawkes_population(
    T: float,
    g0: Callable,
    g0_upper_bound: float,
    kernel: Kernel,
    rng: np.random.Generator = None,
) -> NDArray[float64]:
    """
        Simulate a Hawkes process population using a branching structure (population) approach.

        The process is generated by simulating a first-generation Poisson process
        with intensity `g0`, then recursively simulating offspring arrivals according
        to the kernel.

        Parameters
        ----------
        T : float
            End time of the simulation interval [0, T].
        g0 : Callable
            Baseline intensity function of the Hawkes process.
        g0_upper_bound : float
            Upper bound for thinning-based simulation of the baseline Poisson process.
        kernel : Kernel
            Kernel function governing the self-excitation of the process.
        rng : np.random.Generator, optional
            Random number generator for reproducibility. Default is a new generator with seed 42.

        Returns
        -------
        arrivals : NDArray[float64]
            Sorted array of Hawkes process event times up to time T.
        """
    if rng is None:
        rng = np.random.default_rng(seed=42)
    # simulate the jumps of an inhomogeneous Poisson with intensity g_0(t) via thinning
    hawkes_arrivals = inhomogeneous_poisson_field_on_interval_thinning(a=0, b=T, intensity=g0,
                                                                       intensity_bound=g0_upper_bound,
                                                                       rng=rng)

    ptr = 0
    to_concatenate = []
    while ptr < len(hawkes_arrivals):
        parent_arrival = hawkes_arrivals[ptr]
        # simulating inhomogeneous poisson on [parent_arrival, T] with intensity K(t - parent_arrival)
        descendant_arrivals = parent_arrival + inhomogeneous_poisson_field_on_interval_inversion(a=0,
                                                                                                 b=T - parent_arrival,
                                                                                                 integrated_intensity=kernel.integrated_kernel,
                                                                                                 inv_integrated_intensity=kernel.inv_integrated_kernel,
                                                                                                 rng=rng)
        to_concatenate.append(descendant_arrivals)
        if ptr == len(hawkes_arrivals) - 1 and to_concatenate:
            hawkes_arrivals = np.concatenate([hawkes_arrivals] + to_concatenate)
            to_concatenate = []
        ptr += 1

    hawkes_arrivals = np.sort(hawkes_arrivals)
    return hawkes_arrivals

def simulate_exponential_hawkes(
    T: float,
    kernel: ExponentialKernel,
    mean_intensity: float,
    init_intensity: float,
    rng: np.random.Generator = None,
) -> NDArray[float64]:
    """
    Simulate a trajectory of an exponential Hawkes process using the exact method.

    The intensity of the process evolves as:

       λ_t = a + (λ_0 - a) * exp(-λ * t) + Σ_{T_k < t} c * exp(-λ * (t - T_k))

    where:
    - `a` is the baseline intensity (`mean_intensity`),
    - `λ_0` is the initial intensity (`init_intensity`),
    - `c` and `λ` come from the exponential kernel,
    - `T_k` are previous jump times.

    This method generates arrivals exactly,
    exploiting the memoryless property of the exponential kernel.

    Parameters
    ----------
    T : float
       End time of the simulation interval [0, T].
    kernel : ExponentialKernel
       Exponential kernel K(t) = c * exp(-λ * t) specifying self-excitation.
    mean_intensity : float
       Baseline intensity a of the Hawkes process.
    init_intensity : float
       Initial intensity λ_0 at time t=0.
    rng : np.random.Generator, optional
       Random number generator for reproducibility. Default is a new generator with seed 42.

    Returns
    -------
    arrivals : NDArray[float64]
       Array of event times of the exponential Hawkes process (all < T).
    """
    if rng is None:
        rng = np.random.default_rng(seed=42)

    hawkes_arrivals = []
    lam, c = kernel.lam, kernel.c

    current_intensity = init_intensity + 0.00001
    current_arrival = 0

    while current_arrival < T:
        U = rng.uniform(size=2)
        D = 1 + lam * np.log(U[0]) / (current_intensity - mean_intensity)
        S_2 = -np.log(U[1]) / mean_intensity
        if D > 0:
            S_1 = -np.log(D) / lam
            S = min(S_1, S_2)
        else:
            S = S_2
        current_arrival += S
        current_intensity = (current_intensity - mean_intensity) * np.exp(-lam * S) + mean_intensity + c
        hawkes_arrivals.append(current_arrival)

    return np.array(hawkes_arrivals)[:-1]  # the last arrival is > T.


def simulate_hawkes_ogata(
    T: float,
    mu: float,
    kernel: Union[Callable, Kernel],
    rng: np.random.Generator = None,
    eps: float = 1e-11,
    batch_size: int = 10,
    decreasing_kernel: Union[Callable, Kernel] = None # used to get correct bounds for non-monotone kernels
) -> NDArray[float64]:
    """
    Simulate a general Hawkes process using Ogata's thinning algorithm.

    Parameters
    ----------
    T : float
        End time of the simulation interval [0, T].
    mu : float
        Baseline intensity of the process.
    kernel : Callable or Kernel
        Excitation kernel of the Hawkes process.
    rng : np.random.Generator, optional
        Random number generator for reproducibility. Default is a new generator with seed 42.
    eps : float, optional
        Small value to avoid kernel singularity at 0. Default is 1e-11.
    batch_size : int, optional
        Number of uniform samples to generate per batch. Default is 10.
    decreasing_kernel : Callable or Kernel, optional
        Kernel used to compute upper bounds for non-monotone kernels. Defaults to `kernel`.

    Returns
    -------
    arrivals : NDArray[float64]
        Array of event times of the Hawkes process.
    """
    if rng is None:
        rng = np.random.default_rng(seed=42)
    if decreasing_kernel is None:
        decreasing_kernel = kernel

    ptr = 0
    batch_iter = 0
    event_counter = 0

    uniform_batch = rng.uniform(size=(batch_size, 2))
    arrivals = np.empty(batch_size)

    thinning_step = 0
    M = mu
    is_accepted = False
    while ptr < T:
        if isinstance(kernel, ExponentialKernel):
            M = mu + np.exp(-thinning_step * kernel.lam) * (M - mu) + is_accepted * kernel.c
        else:
            M = mu + decreasing_kernel(ptr - arrivals[:event_counter] + eps).sum()
        thinning_step = - np.log(uniform_batch[batch_iter, 0]) / M
        arrival_cand = ptr + thinning_step

        is_accepted = uniform_batch[batch_iter, 1] < (mu + kernel(arrival_cand - arrivals[:event_counter]).sum()) / M
        if is_accepted:
            arrivals[event_counter] = arrival_cand
            event_counter += 1
            if event_counter == arrivals.size:
                arrivals = np.concatenate([arrivals, np.empty(batch_size)])

        ptr = arrival_cand
        batch_iter += 1
        if batch_iter == batch_size:
            uniform_batch = rng.uniform(size=(batch_size, 2))
            batch_iter = 0

    return arrivals[:event_counter - 1]


def lam_from_jumps(t, t_jumps, kernel: Kernel, g0: Callable):
    """
    Compute the intensity λ_t of a Hawkes process from jump times on `t`.

    Parameters
    ----------
    t : NDArray
        Times at which to evaluate the intensity.
    t_jumps : NDArray
        Array of event times.
    kernel : Kernel
        Excitation kernel of the Hawkes process.
    g0 : Callable
        Baseline intensity function.

    Returns
    -------
    lambda_t : NDArray
        Intensity values at times `t`.
    """
    return g0(t) + np.sum(np.where(t.reshape((-1, 1)) > t_jumps.reshape((1, -1)),
                                   kernel(t.reshape((-1, 1)) - t_jumps.reshape((1, -1))),
                                   0), axis=1)


def U_from_jumps(t, t_jumps, kernel: Kernel, g0_bar: Callable):
    """
    Compute the integrated intensity U_t from jump times.

    Parameters
    ----------
    t : NDArray
        Times at which to evaluate the integrated intensity.
    t_jumps : NDArray
        Array of previous event times.
    kernel : Kernel
        Excitation kernel of the Hawkes process.
    g0_bar : Callable
        Baseline integrated intensity function.

    Returns
    -------
    U_t : NDArray
        Integrated intensity values at times `t`.
    """
    return g0_bar(t) + np.sum(np.where(t.reshape((-1, 1)) > t_jumps.reshape((1, -1)),
                                       kernel.integrated_kernel(t.reshape((-1, 1)) - t_jumps.reshape((1, -1))),
                                       0), axis=1)


def N_from_jumps(t, t_jumps):
    """
    Compute the counting process N_t from jump times.

    Parameters
    ----------
    t : NDArray
        Times at which to evaluate the counting process.
    t_jumps : NDArray
        Array of previous event times.

    Returns
    -------
    N_t : NDArray
        Number of events that occurred by each time in `t`.
    """
    return np.sum(t.reshape((-1, 1)) >= t_jumps.reshape((1, -1)), axis=1)
